# -*- coding: utf-8 -*-
"""BigDataProj.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1my24sHbS0AclUiheeN9CJBbIgKmooG5y

#Установка pyspark, импорт библиотек, создание структур и подготовка данных
"""

#pip install pyspark

from pyspark.sql import SparkSession
from pyspark.sql.types import StructType, StructField, DoubleType, IntegerType, BooleanType
from pyspark.sql.functions import col, rand, when
from pyspark.ml.feature import VectorAssembler, StandardScaler, PolynomialExpansion
from pyspark.ml import Pipeline
from pyspark.ml.regression import LinearRegression, RandomForestRegressor
from pyspark.ml.evaluation import RegressionEvaluator, MulticlassClassificationEvaluator
from pyspark.ml.tuning import ParamGridBuilder, CrossValidator, TrainValidationSplit
from pyspark.ml.regression import GBTRegressor


#sc.setLogLevel("OFF")

spark = SparkSession.builder.appName("AbaloneAgePrediction").getOrCreate()

#Структура для инициализации
initSchema = StructType([
    StructField("Length", IntegerType(), True),
    StructField("Diameter", IntegerType(), True),
    StructField("Height", IntegerType(), True),
    StructField("WholeWeight", DoubleType(), True),
    StructField("ShuckedWeight", DoubleType(), True),
    StructField("VisceraWeight", DoubleType(), True),
    StructField("ShellWeight", DoubleType(), True),
    StructField("Sex_F", IntegerType(), True),
    StructField("Sex_I", IntegerType(), True),
    StructField("Sex_M", IntegerType(), True),
    StructField("Age", DoubleType(), True)
])

#
# goalSchema = StructType([
#     StructField("Length", IntegerType(), True),
#     StructField("Diameter", IntegerType(), True),
#     StructField("Height", IntegerType(), True),
#     StructField("WholeWeight", DoubleType(), True),
#     StructField("ShuckedWeight", DoubleType(), True),
#     StructField("VisceraWeight", DoubleType(), True),
#     StructField("ShellWeight", DoubleType(), True),
#     StructField("Age", DoubleType(), True),
#     StructField("Gen", IntegerType(), True)
# ])

df = spark.read.csv("train_dataset.csv", header=True, schema=initSchema)
# df = df.withColumn("Gen",
#                    when(df["Sex_F"]== 1, 0) \
#                    .when(df["Sex_I"]== 1, 1) \
#                    .when(df["Sex_M"]== 1, 2) \
#                    .otherwise(None))
# df = df.drop("Sex_F", "Sex_I", "Sex_M")
# df = spark.createDataFrame(df.rdd, goalSchema)


df.printSchema()
df.show(20)

nameColumns = ["Length",
              "Diameter",
              "Height",
              "WholeWeight",
              "ShuckedWeight",
              "VisceraWeight",
              "ShellWeight",
              "Sex_F",
              "Sex_I",
              "Sex_M"
              ]

assembler = VectorAssembler(inputCols=nameColumns, outputCol="features")

output = assembler.transform(df)
output.show(5, False)

"""**Scaler**"""

scaler = StandardScaler(inputCol="features", outputCol="scaledFeatures", withMean=True, withStd=True)
scalerModel = scaler.fit(output)
print(scalerModel)
scaledData = scalerModel.transform(output)
scaledData = scaledData.drop("features")
newDF = scaledData.withColumnRenamed("scaledFeatures", "features")
newDF.show(truncate=False)

"""**Data Split**"""

weights = [0.7, 0.3]
train, test = newDF.randomSplit(weights, seed=42)
print("count train =", train.count(), "; count test =", test.count())

# test.orderBy("Age").show()
# train.orderBy("Age").show()

"""#Linear Regression"""

lr = LinearRegression(featuresCol="features", labelCol="Age")

m = lr.fit(train)
resultDF = m.transform(test)
resultDF.show(10)

"""**Quality Rate of LinearRegression**"""

predictions = m.transform(test)

evaluator_rmse = RegressionEvaluator(labelCol="Age", predictionCol="prediction", metricName="rmse")
rmse = evaluator_rmse.evaluate(predictions)
print(f"Root Mean Squared Error (RMSE) on test data = {rmse}")

import matplotlib.pyplot as plt

predictions = resultDF.select("prediction", "Age").orderBy("Age").collect()
predicted_values = [row["prediction"] for row in predictions]
true_values = [row["Age"] for row in predictions]

plt.figure(figsize=(10, 5))
plt.scatter(range(len(predicted_values)), predicted_values, label="Predicted", marker='o', s=10)
plt.scatter(range(len(true_values)), true_values, label="True", marker='x', s=10)
plt.xlabel('Index')
plt.ylabel('Age')
plt.title('Predicted vs True Values')
plt.legend()
plt.show()

"""#DecisionTreeClassifier"""

from pyspark.ml.classification import DecisionTreeClassifier

lr = DecisionTreeClassifier(featuresCol="features", labelCol="Age")

m = lr.fit(train)
resultDF = m.transform(test)
resultDF.orderBy(rand()).show(10)

"""**Quality Rate of DecisionTreeClassifier**"""

resultDF = m.transform(test)

predictions = m.transform(test)


evaluator_rmse = RegressionEvaluator(labelCol="Age", predictionCol="prediction", metricName="rmse")
rmse = evaluator_rmse.evaluate(predictions)
print(f"Root Mean Squared Error (RMSE) on test data = {rmse}")

predictions = resultDF.select("prediction", "Age").orderBy("Age").collect()
predicted_values = [row["prediction"] + 0.5 for row in predictions]  # повысили высоту на 0.5 чтобы были видны
true_values = [row["Age"] for row in predictions]                    # пересечения на графике

plt.figure(figsize=(10, 5))
plt.scatter(range(len(predicted_values)), predicted_values, label="Predicted", marker='o', s=10)
plt.scatter(range(len(true_values)), true_values, label="True", marker='x', s=10)
plt.xlabel('Index  ')
plt.ylabel('Age')
plt.title('Predicted vs True Values')
plt.legend()
plt.show()

"""#RandomForest"""

from pyspark.ml.regression import RandomForestRegressor


# RandomForestRegressor модель
rf = RandomForestRegressor(featuresCol="features", labelCol="Age")

# Параметры GridSearch
paramGrid = ParamGridBuilder() \
    .addGrid(rf.numTrees, [10, 20, 50]) \
    .addGrid(rf.maxDepth, [5, 10, 15]) \
    .addGrid(rf.maxBins, [32, 64, 128]) \
    .build()

# Определение оценщика
evaluator = RegressionEvaluator(
    labelCol="Age", predictionCol="prediction", metricName="rmse")

# Перебор параметров с перекрёстной проверкой
cv = CrossValidator(estimator=rf,
                    estimatorParamMaps=paramGrid,
                    evaluator=evaluator,
                    numFolds=3)  # Количество фолдов

# Обучение модели
cvModel = cv.fit(train)

# Преминение обученной модели к тестовому набору данных
resultDF = cvModel.transform(test)

resultDF.orderBy(rand()).show(10)

bestModel = cvModel.bestModel
print("Best Params:")
print("numTrees: ", bestModel.getNumTrees)
print("maxDepth: ", bestModel.getMaxDepth)
print("maxBins: ", bestModel.getMaxBins)

"""Quality Rate of RandomForest"""

predictions = bestModel.transform(test)

evaluator_rmse = RegressionEvaluator(labelCol="Age", predictionCol="prediction", metricName="rmse")
rmse = evaluator_rmse.evaluate(predictions)
print(f"Root Mean Squared Error (RMSE) on test data = {rmse}")

"""  Без gridSearch'а получалось добиться RMSE только 2.25"""

import matplotlib.pyplot as plt

predictions = resultDF.select("prediction", "Age").orderBy("Age").collect()
predicted_values = [row["prediction"] for row in predictions]
true_values = [row["Age"] for row in predictions]

plt.figure(figsize=(10, 5))
plt.scatter(range(len(predicted_values)), predicted_values, label="Predicted", marker='o', s=10)
plt.scatter(range(len(true_values)), true_values, label="True", marker='x', s=1)
plt.xlabel('Index')
plt.ylabel('Age')
plt.title('Predicted vs True Values')
plt.legend()
plt.show()

"""#PolynomialRegression"""

assembler = VectorAssembler(inputCols=["features"], outputCol="features_vector")
polynomial_expansion = PolynomialExpansion(inputCol="features", outputCol="poly_features", degree=2) # вручную проверено что 2 степень - лучший параметр
lr = LinearRegression(featuresCol="poly_features", labelCol="Age")

pipeline = Pipeline(stages=[assembler, polynomial_expansion, lr])

m = pipeline.fit(train)

resultDF = m.transform(test)

resultDF.show(10, truncate=False)

"""assembler

**Quality Rate of PolynomialRegression**
"""

predictions = m.transform(test)

evaluator_rmse = RegressionEvaluator(labelCol="Age", predictionCol="prediction", metricName="rmse")
rmse = evaluator_rmse.evaluate(predictions)
print(f"Root Mean Squared Error (RMSE) on test data = {rmse}")

predictions = resultDF.select("prediction", "Age").orderBy("Age").collect()
predicted_values = [row["prediction"] for row in predictions]
true_values = [row["Age"] for row in predictions]

plt.figure(figsize=(10, 5))
plt.scatter(range(len(predicted_values)), predicted_values, label="Predicted", marker='o', s=10)
plt.scatter(range(len(true_values)), true_values, label="True", marker='x', s=1)
plt.xlabel('Index  ')
plt.ylabel('Age')
plt.title('Predicted vs True Values')
plt.legend()
plt.show()

"""#GBTRegressor"""

gbt = GBTRegressor(featuresCol="features", labelCol="Age")

# Определяем сетку параметров
paramGrid = ParamGridBuilder() \
    .addGrid(gbt.maxDepth, [5, 10, 15]) \
    .addGrid(gbt.maxBins, [32, 64]) \
    .addGrid(gbt.maxIter, [20, 50, 100]) \
    .build()

# Определяем оценщика
evaluator = RegressionEvaluator(
    labelCol="Age", predictionCol="prediction", metricName="rmse")

# Создание CrossValidator
crossval = CrossValidator(estimator=gbt,
                          estimatorParamMaps=paramGrid,
                          evaluator=evaluator,
                          numFolds=5)  # Количество фолдов в кросс-валидации

# Обучение модели с использованием перекрестной проверки
cvModel = crossval.fit(train)

# Применение обученной модели к тестовому набору данных
resultDF = cvModel.transform(test)

# Выводим результаты
resultDF.show(10)

bestModel = cvModel.bestModel
print("Best Params:")
print("MaxDepth: ", bestModel.getMaxDepth())
print("MaxBins: ", bestModel.getMaxBins())
print("MaxIter: ", bestModel.getMaxIter())

"""**Quality Rate of PolynomialRegression**"""

predictions = bestModel.transform(test)

evaluator_rmse = RegressionEvaluator(labelCol="Age", predictionCol="prediction", metricName="rmse")
rmse = evaluator_rmse.evaluate(predictions)
print(f"Root Mean Squared Error (RMSE) on test data = {rmse}")

predictions = resultDF.select("prediction", "Age").orderBy("Age").collect()
predicted_values = [row["prediction"] for row in predictions]  # повысили высоту на 0.5 чтобы были видны
true_values = [row["Age"] for row in predictions]                    # пересечения на графике

plt.figure(figsize=(10, 5))
plt.scatter(range(len(predicted_values)), predicted_values, label="Predicted", marker='o', s=10)
plt.scatter(range(len(true_values)), true_values, label="True", marker='x', s=1)
plt.xlabel('Index  ')
plt.ylabel('Age')
plt.title('Predicted vs True Values')
plt.legend()
plt.show()